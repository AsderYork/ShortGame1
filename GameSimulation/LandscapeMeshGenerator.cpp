#include "LandscapeMeshGenerator.h"

namespace GEM::GameSim
{
	/**!
	Helper structures and tables from Eric Lengyel's implementation of MarchingCubes
	http://transvoxel.org/.
	*/
	struct RegularCellData
	{
		unsigned char	geometryCounts;		// High nibble is vertex count, low nibble is triangle count.
		unsigned char	vertexIndex[15];	// Groups of 3 indexes giving the triangulation.

		long GetVertexCount(void) const
		{
			return (geometryCounts >> 4);
		}

		long GetTriangleCount(void) const
		{
			return (geometryCounts & 0x0F);
		}
	};
	const unsigned char regularCellClass[256] =
	{
		0x00, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x04, 0x01, 0x02, 0x03, 0x04, 0x03, 0x04, 0x04, 0x03,
		0x01, 0x03, 0x02, 0x04, 0x02, 0x04, 0x06, 0x0C, 0x02, 0x05, 0x05, 0x0B, 0x05, 0x0A, 0x07, 0x04,
		0x01, 0x02, 0x03, 0x04, 0x02, 0x05, 0x05, 0x0A, 0x02, 0x06, 0x04, 0x0C, 0x05, 0x07, 0x0B, 0x04,
		0x03, 0x04, 0x04, 0x03, 0x05, 0x0B, 0x07, 0x04, 0x05, 0x07, 0x0A, 0x04, 0x08, 0x0E, 0x0E, 0x03,
		0x01, 0x02, 0x02, 0x05, 0x03, 0x04, 0x05, 0x0B, 0x02, 0x06, 0x05, 0x07, 0x04, 0x0C, 0x0A, 0x04,
		0x03, 0x04, 0x05, 0x0A, 0x04, 0x03, 0x07, 0x04, 0x05, 0x07, 0x08, 0x0E, 0x0B, 0x04, 0x0E, 0x03,
		0x02, 0x06, 0x05, 0x07, 0x05, 0x07, 0x08, 0x0E, 0x06, 0x09, 0x07, 0x0F, 0x07, 0x0F, 0x0E, 0x0D,
		0x04, 0x0C, 0x0B, 0x04, 0x0A, 0x04, 0x0E, 0x03, 0x07, 0x0F, 0x0E, 0x0D, 0x0E, 0x0D, 0x02, 0x01,
		0x01, 0x02, 0x02, 0x05, 0x02, 0x05, 0x06, 0x07, 0x03, 0x05, 0x04, 0x0A, 0x04, 0x0B, 0x0C, 0x04,
		0x02, 0x05, 0x06, 0x07, 0x06, 0x07, 0x09, 0x0F, 0x05, 0x08, 0x07, 0x0E, 0x07, 0x0E, 0x0F, 0x0D,
		0x03, 0x05, 0x04, 0x0B, 0x05, 0x08, 0x07, 0x0E, 0x04, 0x07, 0x03, 0x04, 0x0A, 0x0E, 0x04, 0x03,
		0x04, 0x0A, 0x0C, 0x04, 0x07, 0x0E, 0x0F, 0x0D, 0x0B, 0x0E, 0x04, 0x03, 0x0E, 0x02, 0x0D, 0x01,
		0x03, 0x05, 0x05, 0x08, 0x04, 0x0A, 0x07, 0x0E, 0x04, 0x07, 0x0B, 0x0E, 0x03, 0x04, 0x04, 0x03,
		0x04, 0x0B, 0x07, 0x0E, 0x0C, 0x04, 0x0F, 0x0D, 0x0A, 0x0E, 0x0E, 0x02, 0x04, 0x03, 0x0D, 0x01,
		0x04, 0x07, 0x0A, 0x0E, 0x0B, 0x0E, 0x0E, 0x02, 0x0C, 0x0F, 0x04, 0x0D, 0x04, 0x0D, 0x03, 0x01,
		0x03, 0x04, 0x04, 0x03, 0x04, 0x03, 0x0D, 0x01, 0x04, 0x0D, 0x03, 0x01, 0x03, 0x01, 0x01, 0x00
	};
	const RegularCellData regularCellData[16] =
	{
		{ 0x00,{} },
	{ 0x31,{ 0, 1, 2 } },
	{ 0x62,{ 0, 1, 2, 3, 4, 5 } },
	{ 0x42,{ 0, 1, 2, 0, 2, 3 } },
	{ 0x53,{ 0, 1, 4, 1, 3, 4, 1, 2, 3 } },
	{ 0x73,{ 0, 1, 2, 0, 2, 3, 4, 5, 6 } },
	{ 0x93,{ 0, 1, 2, 3, 4, 5, 6, 7, 8 } },
	{ 0x84,{ 0, 1, 4, 1, 3, 4, 1, 2, 3, 5, 6, 7 } },
	{ 0x84,{ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7 } },
	{ 0xC4,{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 } },
	{ 0x64,{ 0, 4, 5, 0, 1, 4, 1, 3, 4, 1, 2, 3 } },
	{ 0x64,{ 0, 5, 4, 0, 4, 1, 1, 4, 3, 1, 3, 2 } },
	{ 0x64,{ 0, 4, 5, 0, 3, 4, 0, 1, 3, 1, 2, 3 } },
	{ 0x64,{ 0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5 } },
	{ 0x75,{ 0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6 } },
	{ 0x95,{ 0, 4, 5, 0, 3, 4, 0, 1, 3, 1, 2, 3, 6, 7, 8 } }
	};
	const unsigned short regularVertexData[256][12] =
	{
		{},
	{ 0x6201, 0x5102, 0x3304 },
	{ 0x6201, 0x2315, 0x4113 },
	{ 0x5102, 0x3304, 0x2315, 0x4113 },
	{ 0x5102, 0x4223, 0x1326 },
	{ 0x3304, 0x6201, 0x4223, 0x1326 },
	{ 0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326 },
	{ 0x4223, 0x1326, 0x3304, 0x2315, 0x4113 },
	{ 0x4113, 0x8337, 0x4223 },
	{ 0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337 },
	{ 0x6201, 0x2315, 0x8337, 0x4223 },
	{ 0x5102, 0x3304, 0x2315, 0x8337, 0x4223 },
	{ 0x5102, 0x4113, 0x8337, 0x1326 },
	{ 0x4113, 0x8337, 0x1326, 0x3304, 0x6201 },
	{ 0x6201, 0x2315, 0x8337, 0x1326, 0x5102 },
	{ 0x3304, 0x2315, 0x8337, 0x1326 },
	{ 0x3304, 0x1146, 0x2245 },
	{ 0x6201, 0x5102, 0x1146, 0x2245 },
	{ 0x6201, 0x2315, 0x4113, 0x3304, 0x1146, 0x2245 },
	{ 0x2315, 0x4113, 0x5102, 0x1146, 0x2245 },
	{ 0x5102, 0x4223, 0x1326, 0x3304, 0x1146, 0x2245 },
	{ 0x1146, 0x2245, 0x6201, 0x4223, 0x1326 },
	{ 0x3304, 0x1146, 0x2245, 0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326 },
	{ 0x4223, 0x1326, 0x1146, 0x2245, 0x2315, 0x4113 },
	{ 0x4223, 0x4113, 0x8337, 0x3304, 0x1146, 0x2245 },
	{ 0x6201, 0x5102, 0x1146, 0x2245, 0x4223, 0x4113, 0x8337 },
	{ 0x4223, 0x6201, 0x2315, 0x8337, 0x3304, 0x1146, 0x2245 },
	{ 0x4223, 0x8337, 0x2315, 0x2245, 0x1146, 0x5102 },
	{ 0x5102, 0x4113, 0x8337, 0x1326, 0x3304, 0x1146, 0x2245 },
	{ 0x4113, 0x8337, 0x1326, 0x1146, 0x2245, 0x6201 },
	{ 0x6201, 0x2315, 0x8337, 0x1326, 0x5102, 0x3304, 0x1146, 0x2245 },
	{ 0x2245, 0x2315, 0x8337, 0x1326, 0x1146 },
	{ 0x2315, 0x2245, 0x8157 },
	{ 0x6201, 0x5102, 0x3304, 0x2315, 0x2245, 0x8157 },
	{ 0x4113, 0x6201, 0x2245, 0x8157 },
	{ 0x2245, 0x8157, 0x4113, 0x5102, 0x3304 },
	{ 0x5102, 0x4223, 0x1326, 0x2315, 0x2245, 0x8157 },
	{ 0x6201, 0x4223, 0x1326, 0x3304, 0x2315, 0x2245, 0x8157 },
	{ 0x6201, 0x2245, 0x8157, 0x4113, 0x5102, 0x4223, 0x1326 },
	{ 0x4223, 0x1326, 0x3304, 0x2245, 0x8157, 0x4113 },
	{ 0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157 },
	{ 0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157 },
	{ 0x8337, 0x4223, 0x6201, 0x2245, 0x8157 },
	{ 0x5102, 0x3304, 0x2245, 0x8157, 0x8337, 0x4223 },
	{ 0x5102, 0x4113, 0x8337, 0x1326, 0x2315, 0x2245, 0x8157 },
	{ 0x4113, 0x8337, 0x1326, 0x3304, 0x6201, 0x2315, 0x2245, 0x8157 },
	{ 0x5102, 0x1326, 0x8337, 0x8157, 0x2245, 0x6201 },
	{ 0x8157, 0x8337, 0x1326, 0x3304, 0x2245 },
	{ 0x2315, 0x3304, 0x1146, 0x8157 },
	{ 0x6201, 0x5102, 0x1146, 0x8157, 0x2315 },
	{ 0x3304, 0x1146, 0x8157, 0x4113, 0x6201 },
	{ 0x4113, 0x5102, 0x1146, 0x8157 },
	{ 0x2315, 0x3304, 0x1146, 0x8157, 0x5102, 0x4223, 0x1326 },
	{ 0x1326, 0x4223, 0x6201, 0x2315, 0x8157, 0x1146 },
	{ 0x3304, 0x1146, 0x8157, 0x4113, 0x6201, 0x5102, 0x4223, 0x1326 },
	{ 0x1326, 0x1146, 0x8157, 0x4113, 0x4223 },
	{ 0x2315, 0x3304, 0x1146, 0x8157, 0x4223, 0x4113, 0x8337 },
	{ 0x6201, 0x5102, 0x1146, 0x8157, 0x2315, 0x4223, 0x4113, 0x8337 },
	{ 0x3304, 0x1146, 0x8157, 0x8337, 0x4223, 0x6201 },
	{ 0x4223, 0x5102, 0x1146, 0x8157, 0x8337 },
	{ 0x2315, 0x3304, 0x1146, 0x8157, 0x5102, 0x4113, 0x8337, 0x1326 },
	{ 0x6201, 0x4113, 0x8337, 0x1326, 0x1146, 0x8157, 0x2315 },
	{ 0x6201, 0x3304, 0x1146, 0x8157, 0x8337, 0x1326, 0x5102 },
	{ 0x1326, 0x1146, 0x8157, 0x8337 },
	{ 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x5102, 0x3304, 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x2315, 0x4113, 0x1326, 0x8267, 0x1146 },
	{ 0x5102, 0x3304, 0x2315, 0x4113, 0x1326, 0x8267, 0x1146 },
	{ 0x5102, 0x4223, 0x8267, 0x1146 },
	{ 0x3304, 0x6201, 0x4223, 0x8267, 0x1146 },
	{ 0x5102, 0x4223, 0x8267, 0x1146, 0x6201, 0x2315, 0x4113 },
	{ 0x1146, 0x8267, 0x4223, 0x4113, 0x2315, 0x3304 },
	{ 0x4113, 0x8337, 0x4223, 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x2315, 0x8337, 0x4223, 0x1326, 0x8267, 0x1146 },
	{ 0x5102, 0x3304, 0x2315, 0x8337, 0x4223, 0x1326, 0x8267, 0x1146 },
	{ 0x8267, 0x1146, 0x5102, 0x4113, 0x8337 },
	{ 0x6201, 0x4113, 0x8337, 0x8267, 0x1146, 0x3304 },
	{ 0x6201, 0x2315, 0x8337, 0x8267, 0x1146, 0x5102 },
	{ 0x1146, 0x3304, 0x2315, 0x8337, 0x8267 },
	{ 0x3304, 0x1326, 0x8267, 0x2245 },
	{ 0x1326, 0x8267, 0x2245, 0x6201, 0x5102 },
	{ 0x3304, 0x1326, 0x8267, 0x2245, 0x6201, 0x2315, 0x4113 },
	{ 0x1326, 0x8267, 0x2245, 0x2315, 0x4113, 0x5102 },
	{ 0x5102, 0x4223, 0x8267, 0x2245, 0x3304 },
	{ 0x6201, 0x4223, 0x8267, 0x2245 },
	{ 0x5102, 0x4223, 0x8267, 0x2245, 0x3304, 0x6201, 0x2315, 0x4113 },
	{ 0x4113, 0x4223, 0x8267, 0x2245, 0x2315 },
	{ 0x3304, 0x1326, 0x8267, 0x2245, 0x4223, 0x4113, 0x8337 },
	{ 0x1326, 0x8267, 0x2245, 0x6201, 0x5102, 0x4223, 0x4113, 0x8337 },
	{ 0x3304, 0x1326, 0x8267, 0x2245, 0x4223, 0x6201, 0x2315, 0x8337 },
	{ 0x5102, 0x1326, 0x8267, 0x2245, 0x2315, 0x8337, 0x4223 },
	{ 0x3304, 0x2245, 0x8267, 0x8337, 0x4113, 0x5102 },
	{ 0x8337, 0x8267, 0x2245, 0x6201, 0x4113 },
	{ 0x5102, 0x6201, 0x2315, 0x8337, 0x8267, 0x2245, 0x3304 },
	{ 0x2315, 0x8337, 0x8267, 0x2245 },
	{ 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x5102, 0x3304, 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x2245, 0x8157, 0x4113, 0x1326, 0x8267, 0x1146 },
	{ 0x2245, 0x8157, 0x4113, 0x5102, 0x3304, 0x1326, 0x8267, 0x1146 },
	{ 0x4223, 0x8267, 0x1146, 0x5102, 0x2315, 0x2245, 0x8157 },
	{ 0x3304, 0x6201, 0x4223, 0x8267, 0x1146, 0x2315, 0x2245, 0x8157 },
	{ 0x4223, 0x8267, 0x1146, 0x5102, 0x6201, 0x2245, 0x8157, 0x4113 },
	{ 0x3304, 0x2245, 0x8157, 0x4113, 0x4223, 0x8267, 0x1146 },
	{ 0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146 },
	{ 0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146 },
	{ 0x8337, 0x4223, 0x6201, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146 },
	{ 0x4223, 0x5102, 0x3304, 0x2245, 0x8157, 0x8337, 0x1326, 0x8267, 0x1146 },
	{ 0x8267, 0x1146, 0x5102, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157 },
	{ 0x6201, 0x4113, 0x8337, 0x8267, 0x1146, 0x3304, 0x2315, 0x2245, 0x8157 },
	{ 0x8337, 0x8267, 0x1146, 0x5102, 0x6201, 0x2245, 0x8157 },
	{ 0x3304, 0x2245, 0x8157, 0x8337, 0x8267, 0x1146 },
	{ 0x8157, 0x2315, 0x3304, 0x1326, 0x8267 },
	{ 0x8267, 0x8157, 0x2315, 0x6201, 0x5102, 0x1326 },
	{ 0x8267, 0x1326, 0x3304, 0x6201, 0x4113, 0x8157 },
	{ 0x8267, 0x8157, 0x4113, 0x5102, 0x1326 },
	{ 0x5102, 0x4223, 0x8267, 0x8157, 0x2315, 0x3304 },
	{ 0x2315, 0x6201, 0x4223, 0x8267, 0x8157 },
	{ 0x3304, 0x5102, 0x4223, 0x8267, 0x8157, 0x4113, 0x6201 },
	{ 0x4113, 0x4223, 0x8267, 0x8157 },
	{ 0x8157, 0x2315, 0x3304, 0x1326, 0x8267, 0x4223, 0x4113, 0x8337 },
	{ 0x8157, 0x2315, 0x6201, 0x5102, 0x1326, 0x8267, 0x4223, 0x4113, 0x8337 },
	{ 0x8157, 0x8337, 0x4223, 0x6201, 0x3304, 0x1326, 0x8267 },
	{ 0x5102, 0x1326, 0x8267, 0x8157, 0x8337, 0x4223 },
	{ 0x8267, 0x8157, 0x2315, 0x3304, 0x5102, 0x4113, 0x8337 },
	{ 0x6201, 0x4113, 0x8337, 0x8267, 0x8157, 0x2315 },
	{ 0x6201, 0x3304, 0x5102, 0x8337, 0x8267, 0x8157 },
	{ 0x8337, 0x8267, 0x8157 },
	{ 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x5102, 0x3304, 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x2315, 0x4113, 0x8337, 0x8157, 0x8267 },
	{ 0x5102, 0x3304, 0x2315, 0x4113, 0x8337, 0x8157, 0x8267 },
	{ 0x5102, 0x4223, 0x1326, 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x4223, 0x1326, 0x3304, 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326, 0x8337, 0x8157, 0x8267 },
	{ 0x4223, 0x1326, 0x3304, 0x2315, 0x4113, 0x8337, 0x8157, 0x8267 },
	{ 0x4113, 0x8157, 0x8267, 0x4223 },
	{ 0x4223, 0x4113, 0x8157, 0x8267, 0x6201, 0x5102, 0x3304 },
	{ 0x8157, 0x8267, 0x4223, 0x6201, 0x2315 },
	{ 0x3304, 0x2315, 0x8157, 0x8267, 0x4223, 0x5102 },
	{ 0x1326, 0x5102, 0x4113, 0x8157, 0x8267 },
	{ 0x8157, 0x4113, 0x6201, 0x3304, 0x1326, 0x8267 },
	{ 0x1326, 0x5102, 0x6201, 0x2315, 0x8157, 0x8267 },
	{ 0x8267, 0x1326, 0x3304, 0x2315, 0x8157 },
	{ 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x5102, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x2315, 0x4113, 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267 },
	{ 0x2315, 0x4113, 0x5102, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267 },
	{ 0x5102, 0x4223, 0x1326, 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267 },
	{ 0x1146, 0x2245, 0x6201, 0x4223, 0x1326, 0x8337, 0x8157, 0x8267 },
	{ 0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326, 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267 },
	{ 0x4113, 0x4223, 0x1326, 0x1146, 0x2245, 0x2315, 0x8337, 0x8157, 0x8267 },
	{ 0x4223, 0x4113, 0x8157, 0x8267, 0x3304, 0x1146, 0x2245 },
	{ 0x6201, 0x5102, 0x1146, 0x2245, 0x4223, 0x4113, 0x8157, 0x8267 },
	{ 0x8157, 0x8267, 0x4223, 0x6201, 0x2315, 0x3304, 0x1146, 0x2245 },
	{ 0x2315, 0x8157, 0x8267, 0x4223, 0x5102, 0x1146, 0x2245 },
	{ 0x1326, 0x5102, 0x4113, 0x8157, 0x8267, 0x3304, 0x1146, 0x2245 },
	{ 0x1326, 0x1146, 0x2245, 0x6201, 0x4113, 0x8157, 0x8267 },
	{ 0x5102, 0x6201, 0x2315, 0x8157, 0x8267, 0x1326, 0x3304, 0x1146, 0x2245 },
	{ 0x1326, 0x1146, 0x2245, 0x2315, 0x8157, 0x8267 },
	{ 0x2315, 0x2245, 0x8267, 0x8337 },
	{ 0x2315, 0x2245, 0x8267, 0x8337, 0x6201, 0x5102, 0x3304 },
	{ 0x4113, 0x6201, 0x2245, 0x8267, 0x8337 },
	{ 0x5102, 0x4113, 0x8337, 0x8267, 0x2245, 0x3304 },
	{ 0x2315, 0x2245, 0x8267, 0x8337, 0x5102, 0x4223, 0x1326 },
	{ 0x6201, 0x4223, 0x1326, 0x3304, 0x8337, 0x2315, 0x2245, 0x8267 },
	{ 0x4113, 0x6201, 0x2245, 0x8267, 0x8337, 0x5102, 0x4223, 0x1326 },
	{ 0x4113, 0x4223, 0x1326, 0x3304, 0x2245, 0x8267, 0x8337 },
	{ 0x2315, 0x2245, 0x8267, 0x4223, 0x4113 },
	{ 0x2315, 0x2245, 0x8267, 0x4223, 0x4113, 0x6201, 0x5102, 0x3304 },
	{ 0x6201, 0x2245, 0x8267, 0x4223 },
	{ 0x3304, 0x2245, 0x8267, 0x4223, 0x5102 },
	{ 0x5102, 0x4113, 0x2315, 0x2245, 0x8267, 0x1326 },
	{ 0x4113, 0x2315, 0x2245, 0x8267, 0x1326, 0x3304, 0x6201 },
	{ 0x5102, 0x6201, 0x2245, 0x8267, 0x1326 },
	{ 0x3304, 0x2245, 0x8267, 0x1326 },
	{ 0x8267, 0x8337, 0x2315, 0x3304, 0x1146 },
	{ 0x5102, 0x1146, 0x8267, 0x8337, 0x2315, 0x6201 },
	{ 0x3304, 0x1146, 0x8267, 0x8337, 0x4113, 0x6201 },
	{ 0x8337, 0x4113, 0x5102, 0x1146, 0x8267 },
	{ 0x8267, 0x8337, 0x2315, 0x3304, 0x1146, 0x5102, 0x4223, 0x1326 },
	{ 0x1146, 0x8267, 0x8337, 0x2315, 0x6201, 0x4223, 0x1326 },
	{ 0x8267, 0x8337, 0x4113, 0x6201, 0x3304, 0x1146, 0x5102, 0x4223, 0x1326 },
	{ 0x4113, 0x4223, 0x1326, 0x1146, 0x8267, 0x8337 },
	{ 0x3304, 0x2315, 0x4113, 0x4223, 0x8267, 0x1146 },
	{ 0x2315, 0x6201, 0x5102, 0x1146, 0x8267, 0x4223, 0x4113 },
	{ 0x1146, 0x8267, 0x4223, 0x6201, 0x3304 },
	{ 0x5102, 0x1146, 0x8267, 0x4223 },
	{ 0x8267, 0x1326, 0x5102, 0x4113, 0x2315, 0x3304, 0x1146 },
	{ 0x6201, 0x4113, 0x2315, 0x1326, 0x1146, 0x8267 },
	{ 0x6201, 0x3304, 0x1146, 0x8267, 0x1326, 0x5102 },
	{ 0x1326, 0x1146, 0x8267 },
	{ 0x1326, 0x8337, 0x8157, 0x1146 },
	{ 0x8337, 0x8157, 0x1146, 0x1326, 0x6201, 0x5102, 0x3304 },
	{ 0x8337, 0x8157, 0x1146, 0x1326, 0x6201, 0x2315, 0x4113 },
	{ 0x4113, 0x5102, 0x3304, 0x2315, 0x1326, 0x8337, 0x8157, 0x1146 },
	{ 0x8337, 0x8157, 0x1146, 0x5102, 0x4223 },
	{ 0x6201, 0x4223, 0x8337, 0x8157, 0x1146, 0x3304 },
	{ 0x8337, 0x8157, 0x1146, 0x5102, 0x4223, 0x6201, 0x2315, 0x4113 },
	{ 0x4223, 0x8337, 0x8157, 0x1146, 0x3304, 0x2315, 0x4113 },
	{ 0x4223, 0x4113, 0x8157, 0x1146, 0x1326 },
	{ 0x4223, 0x4113, 0x8157, 0x1146, 0x1326, 0x6201, 0x5102, 0x3304 },
	{ 0x1146, 0x8157, 0x2315, 0x6201, 0x4223, 0x1326 },
	{ 0x4223, 0x5102, 0x3304, 0x2315, 0x8157, 0x1146, 0x1326 },
	{ 0x4113, 0x8157, 0x1146, 0x5102 },
	{ 0x6201, 0x4113, 0x8157, 0x1146, 0x3304 },
	{ 0x2315, 0x8157, 0x1146, 0x5102, 0x6201 },
	{ 0x2315, 0x8157, 0x1146, 0x3304 },
	{ 0x2245, 0x3304, 0x1326, 0x8337, 0x8157 },
	{ 0x6201, 0x2245, 0x8157, 0x8337, 0x1326, 0x5102 },
	{ 0x2245, 0x3304, 0x1326, 0x8337, 0x8157, 0x6201, 0x2315, 0x4113 },
	{ 0x2245, 0x2315, 0x4113, 0x5102, 0x1326, 0x8337, 0x8157 },
	{ 0x4223, 0x8337, 0x8157, 0x2245, 0x3304, 0x5102 },
	{ 0x8157, 0x2245, 0x6201, 0x4223, 0x8337 },
	{ 0x2245, 0x3304, 0x5102, 0x4223, 0x8337, 0x8157, 0x4113, 0x6201, 0x2315 },
	{ 0x4223, 0x8337, 0x8157, 0x2245, 0x2315, 0x4113 },
	{ 0x4113, 0x8157, 0x2245, 0x3304, 0x1326, 0x4223 },
	{ 0x1326, 0x4223, 0x4113, 0x8157, 0x2245, 0x6201, 0x5102 },
	{ 0x8157, 0x2245, 0x3304, 0x1326, 0x4223, 0x6201, 0x2315 },
	{ 0x5102, 0x1326, 0x4223, 0x2315, 0x8157, 0x2245 },
	{ 0x3304, 0x5102, 0x4113, 0x8157, 0x2245 },
	{ 0x4113, 0x8157, 0x2245, 0x6201 },
	{ 0x5102, 0x6201, 0x2315, 0x8157, 0x2245, 0x3304 },
	{ 0x2315, 0x8157, 0x2245 },
	{ 0x1146, 0x1326, 0x8337, 0x2315, 0x2245 },
	{ 0x1146, 0x1326, 0x8337, 0x2315, 0x2245, 0x6201, 0x5102, 0x3304 },
	{ 0x6201, 0x2245, 0x1146, 0x1326, 0x8337, 0x4113 },
	{ 0x2245, 0x1146, 0x1326, 0x8337, 0x4113, 0x5102, 0x3304 },
	{ 0x5102, 0x1146, 0x2245, 0x2315, 0x8337, 0x4223 },
	{ 0x1146, 0x3304, 0x6201, 0x4223, 0x8337, 0x2315, 0x2245 },
	{ 0x8337, 0x4113, 0x6201, 0x2245, 0x1146, 0x5102, 0x4223 },
	{ 0x4223, 0x8337, 0x4113, 0x3304, 0x2245, 0x1146 },
	{ 0x4113, 0x2315, 0x2245, 0x1146, 0x1326, 0x4223 },
	{ 0x1146, 0x1326, 0x4223, 0x4113, 0x2315, 0x2245, 0x6201, 0x5102, 0x3304 },
	{ 0x1326, 0x4223, 0x6201, 0x2245, 0x1146 },
	{ 0x4223, 0x5102, 0x3304, 0x2245, 0x1146, 0x1326 },
	{ 0x2245, 0x1146, 0x5102, 0x4113, 0x2315 },
	{ 0x4113, 0x2315, 0x2245, 0x1146, 0x3304, 0x6201 },
	{ 0x6201, 0x2245, 0x1146, 0x5102 },
	{ 0x3304, 0x2245, 0x1146 },
	{ 0x3304, 0x1326, 0x8337, 0x2315 },
	{ 0x5102, 0x1326, 0x8337, 0x2315, 0x6201 },
	{ 0x6201, 0x3304, 0x1326, 0x8337, 0x4113 },
	{ 0x5102, 0x1326, 0x8337, 0x4113 },
	{ 0x4223, 0x8337, 0x2315, 0x3304, 0x5102 },
	{ 0x6201, 0x4223, 0x8337, 0x2315 },
	{ 0x3304, 0x5102, 0x4223, 0x8337, 0x4113, 0x6201 },
	{ 0x4113, 0x4223, 0x8337 },
	{ 0x4113, 0x2315, 0x3304, 0x1326, 0x4223 },
	{ 0x1326, 0x4223, 0x4113, 0x2315, 0x6201, 0x5102 },
	{ 0x3304, 0x1326, 0x4223, 0x6201 },
	{ 0x5102, 0x1326, 0x4223 },
	{ 0x5102, 0x4113, 0x2315, 0x3304 },
	{ 0x6201, 0x4113, 0x2315 },
	{ 0x6201, 0x3304, 0x5102 },
	{}
	};

	struct Cords3d {
		int x, y, z;
	};

	inline Cords3d getNodeCordsByIndex(Cords3d cubePos, int nodeIndex)
	{
		switch (nodeIndex)
		{
			case 0: return Cords3d{ cubePos.x - 1, cubePos.y, cubePos.z - 1 };
			case 1: return Cords3d{cubePos.x, cubePos.y, cubePos.z - 1};
			case 2: return Cords3d{cubePos.x - 1, cubePos.y, cubePos.z};
			case 3: return Cords3d{cubePos.x, cubePos.y, cubePos.z};
			case 4: return Cords3d{cubePos.x - 1, cubePos.y + 1, cubePos.z - 1};
			case 5: return Cords3d{cubePos.x, cubePos.y + 1, cubePos.z - 1};
			case 6: return Cords3d{cubePos.x - 1, cubePos.y + 1, cubePos.z};
			case 7: return Cords3d{cubePos.x, cubePos.y + 1, cubePos.z};			
		}
	}

void LandscapeMeshGenerator::ProcessOneCube(int x, int y, int z, bool RegisterNewVertices, ProcessingData& tmpData)
{
	int8_t corner[8];
	corner[0] = getNodeValue(x - 1	, y		, z	- 1	, tmpData) - 128;
	corner[1] = getNodeValue(x   	, y		, z	- 1 , tmpData) - 128;
	corner[2] = getNodeValue(x - 1	, y 	, z		, tmpData) - 128;
	corner[3] = getNodeValue(x   	, y		, z		, tmpData) - 128;
	corner[4] = getNodeValue(x - 1	, y +1 	, z	- 1	, tmpData) - 128;
	corner[5] = getNodeValue(x   	, y +1	, z	- 1	, tmpData) - 128;
	corner[6] = getNodeValue(x - 1	, y +1	, z		, tmpData) - 128;
	corner[7] = getNodeValue(x   	, y +1	, z		, tmpData) - 128;

	unsigned long caseCode = 0;
	caseCode += corner[0] > 0 ? 1   : 0;
	caseCode += corner[1] > 0 ? 2   : 0;
	caseCode += corner[2] > 0 ? 4   : 0;
	caseCode += corner[3] > 0 ? 8   : 0;
	caseCode += corner[4] > 0 ? 16  : 0;
	caseCode += corner[5] > 0 ? 32  : 0;
	caseCode += corner[6] > 0 ? 64  : 0;
	caseCode += corner[7] > 0 ? 128 : 0;

	if (caseCode == 0 || caseCode == 255)
	{
		return;
	}
	//Otherwise cell has a non-trivial triangulation

	char ValidityMask = 0;
	ValidityMask += x > 1 ? 0x10 : 0;
	ValidityMask += z > 1 ? 0x20 : 0;
	ValidityMask += y > 0 ? 0x40 : 0;
		
	//Stores 12 indexes of a vertices, that where used for this cube
	uint32_t IndexHolder[12];
	memset(IndexHolder, 0xff, sizeof(uint32_t) * 12);

	//Holds ptrs for 12 last used vertices in cells.
	CellRepresentation::PerVertex* NormalsPtrHolder[12];
	for (int Vertex = 0; Vertex < regularCellData[regularCellClass[caseCode]].GetVertexCount(); Vertex++)
	{
		auto edgeCode = regularVertexData[caseCode][Vertex];
		auto posx = 1 + x - ((((edgeCode >> 8) & 0x10) != 0) ? 1 : 0);
		auto posy = (y + ((((edgeCode >> 8) & 0x40) != 0) ? 1 : 0)) % 2;
		auto posz = 1 + z - ((((edgeCode >> 8) & 0x20) != 0) ? 1 : 0);
		auto Edgecc = ((edgeCode >> 8) & 0x0f) - 1;

		if (((edgeCode >> 8) & ValidityMask) == 0)
		{//If vertex needs to be added
			auto& CurrVertex = tmpData.NodeDecks[posy][posx][posz].Vertex[Edgecc];

			if (CurrVertex == std::numeric_limits<uint32_t>::max())
			{//Create new vertex

				unsigned short v0 = (edgeCode >> 4) & 0x0F;
				unsigned short v1 = edgeCode & 0x0F;
				float t = (float)corner[v1] / (corner[v1] - corner[v0]);

				char shiftx = edgeCode >> 8 & 0x10 ? 1 : 0;
				char shiftz = edgeCode >> 8 & 0x20 ? 1 : 0;
				char shifty = edgeCode >> 8 & 0x40 ? 1 : 0;

				btVector3 NewVertex;
				switch ((edgeCode >> 8) & 0x0f)
				{
				case 1: {NewVertex = btVector3((btScalar)x, (btScalar)y, (btScalar)(z - t)); break; }
				case 2: {NewVertex = btVector3((btScalar)(x - t), (btScalar)y, (btScalar)z); break; }
				case 3: {NewVertex = btVector3((btScalar)x, (btScalar)(y - t), (btScalar)z); break; }
				default:
					break;
				}
				NewVertex -= btVector3((btScalar)(shiftx), (btScalar)(shifty), (btScalar)(shiftz));

				/**!
				Create new vertices only if flag is set, otherwise just remember positions for later normals calculations
				*/
				if (RegisterNewVertices)
				{
					auto v0Cords = getNodeCordsByIndex({ x,y,z }, v0);
					auto v1Cords = getNodeCordsByIndex({ x,y,z }, v1);

					tmpData.tmpMesh.m_vertices.emplace_back(NewVertex,
						&getNode(v0Cords.x, v0Cords.y, v0Cords.z, tmpData),
						&getNode(v1Cords.x, v1Cords.y, v1Cords.z, tmpData));

					CurrVertex = static_cast<uint32_t>(tmpData.tmpMesh.m_vertices.size() - 1);
					IndexHolder[Vertex] = CurrVertex;
				}


				tmpData.NodeDecks[posy][posx][posz].data[Edgecc].pos = NewVertex;
				/**!
				When we work with deck it's important to remember, that it gets reset from time to time. and
				it resets with 0xff so right after reset, values of normal would not be zeroes, they would be garbage
				To avoid that, whenever we create a new vertex, we also check corresponding normal in a deck and if last value
				(which allways should be zero) contains garbage, then all the normal is garbage and needs to be reset
				*/
				if (tmpData.NodeDecks[posy][posx][posz].data[Edgecc].normal.w() != 0)
				{
					tmpData.NodeDecks[posy][posx][posz].data[Edgecc].normal.setZero();
				}

				NormalsPtrHolder[Vertex] = &tmpData.NodeDecks[posy][posx][posz].data[Edgecc];
			}
			else
			{
				//We allready created this vertex during this pass, so just find it again!
				//Notice that we're adding to IndexHolder even if we're just calculating normals
				//This is done to allow new normal values to be applied to a vertex if it's allready exist
				IndexHolder[Vertex] = tmpData.NodeDecks[posy][posx][posz].Vertex[Edgecc];
				NormalsPtrHolder[Vertex] = &tmpData.NodeDecks[posy][posx][posz].data[Edgecc];
			}

		}
		else
		{
			auto vrtx = tmpData.NodeDecks[posy][posx][posz];
			//Add index of a requested vertex in Indices;
			IndexHolder[Vertex] = tmpData.NodeDecks[posy][posx][posz].Vertex[Edgecc];
			NormalsPtrHolder[Vertex] = &tmpData.NodeDecks[posy][posx][posz].data[Edgecc];
		}
	}

	for (int traingle = 0; traingle < regularCellData[regularCellClass[caseCode]].GetTriangleCount(); traingle++)
	{
		//triangles are twisted, becouse culling mode in tables is not the same as in a game
		auto Ind1 = regularCellData[regularCellClass[caseCode]].vertexIndex[traingle * 3 + 0];
		auto Ind2 = regularCellData[regularCellClass[caseCode]].vertexIndex[traingle * 3 + 2];
		auto Ind3 = regularCellData[regularCellClass[caseCode]].vertexIndex[traingle * 3 + 1];

		auto norm = (NormalsPtrHolder[Ind1]->pos - NormalsPtrHolder[Ind2]->pos).cross(NormalsPtrHolder[Ind1]->pos - NormalsPtrHolder[Ind3]->pos);


		NormalsPtrHolder[Ind1]->normal += norm;
		NormalsPtrHolder[Ind2]->normal += norm;
		NormalsPtrHolder[Ind3]->normal += norm;

		if (RegisterNewVertices)
		{
			tmpData.tmpMesh.m_indices.push_back(IndexHolder[Ind1]);
			tmpData.tmpMesh.m_indices.push_back(IndexHolder[Ind2]);
			tmpData.tmpMesh.m_indices.push_back(IndexHolder[Ind3]);

			tmpData.tmpMesh.m_vertices[IndexHolder[Ind1]].normal = NormalsPtrHolder[Ind1]->normal;
			tmpData.tmpMesh.m_vertices[IndexHolder[Ind2]].normal = NormalsPtrHolder[Ind2]->normal;
			tmpData.tmpMesh.m_vertices[IndexHolder[Ind3]].normal = NormalsPtrHolder[Ind3]->normal;

			triangleType newTriangle;
			newTriangle.indices[0] = IndexHolder[Ind1];
			newTriangle.indices[1] = IndexHolder[Ind2];
			newTriangle.indices[2] = IndexHolder[Ind3];
			newTriangle.normal = norm;
			tmpData.tmpMesh.m_triangles.emplace_back(std::move(newTriangle));
		}
		else
		{
			if (IndexHolder[Ind1] != std::numeric_limits<uint32_t>::max()) { tmpData.tmpMesh.m_vertices[IndexHolder[Ind1]].normal = NormalsPtrHolder[Ind1]->normal; }
			if (IndexHolder[Ind2] != std::numeric_limits<uint32_t>::max()) { tmpData.tmpMesh.m_vertices[IndexHolder[Ind2]].normal = NormalsPtrHolder[Ind2]->normal; }
			if (IndexHolder[Ind3] != std::numeric_limits<uint32_t>::max()) { tmpData.tmpMesh.m_vertices[IndexHolder[Ind3]].normal = NormalsPtrHolder[Ind3]->normal; }
		}

	}



}

LandscapeMesh LandscapeMeshGenerator::Generate(LandscapeChunk* ChunkCenter, LandscapeChunk* ChunkForward, LandscapeChunk* ChunkRight, LandscapeChunk* ChunkForwardRight)
{
	ProcessingData CurrData;
	CurrData.m_chunkCenter = ChunkCenter;
	CurrData.m_chunkForward = ChunkForward;
	CurrData.m_chunkRight = ChunkRight;
	CurrData.m_chunkForwardRight = ChunkForwardRight;

	for (int y = 0; y < LandscapeChunk_Height - 1; y++)
	{

		//Process first z-row withoud adding vertices. It is used only for normals!
		for (int x = 0; x < LandscapeChunk_Size + 2; x++)
		{
			ProcessOneCube(x, y, 0, false, CurrData);
		}

		//Process actual landscape
		for (int z = 1; z < LandscapeChunk_Size + 1; z++)
		{
			ProcessOneCube(0, y, z, false, CurrData);//Skip one in the beginning
			for (int x = 1; x < LandscapeChunk_Size + 1; x++)
			{
				ProcessOneCube(x, y, z, true, CurrData);
			}
			ProcessOneCube(LandscapeChunk_Size + 1, y, z, false, CurrData);//And one at the end
		}
		//Process first z-row withoud adding vertices. It is used only for normals!
		for (int x = 0; x < LandscapeChunk_Size + 2; x++)
		{
			ProcessOneCube(x, y, LandscapeChunk_Size + 1, false, CurrData);
		}




		//Clear last layer;
		memset(CurrData.NodeDecks + ((y + 1) % 2), 0xff, sizeof(CellRepresentation)*(LandscapeChunk_Size + 3)*(LandscapeChunk_Size + 3));

	}
	return CurrData.tmpMesh;
}


}